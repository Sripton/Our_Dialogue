Postcard components
{
  /* <div className={`comment-section ${isDotsActive ? "show-actions" : ""}`}>
<button className="toggle-comments-btn" onClick={handleShowComments}>
  {`${showComments ? "Скрыть" : "Комментарии"} ${comments.length}`}
</button>
<div className="comment-list">
  <div className="comment">
    <p className="comment-text">{`${post.posttitle}`}</p>
    <div className="comment-actions">
      <button className="like-btn">
        <ion-icon class="thumbs" name="thumbs-up-outline"></ion-icon> 0
      </button>
      <button className="dislike-btn">
        <ion-icon class="thumbs" name="thumbs-down-outline"></ion-icon>{" "}
        0
      </button>
      <button className="reply-btn" onClick={handleShowReplies}>
        reply
      </button>
      <button className="edit-btn">Edit</button>
      <button className="delete-btn">Delete</button>
      <small className="comment-note">
        {post?.User?.name}, ({post?.Subject?.subjectName})
      </small>
    </div>

    <div className="dots" onClick={handleDots}>
      &#x2022;&#x2022;&#x2022;
    </div>
    <div className="close-btn hidden" onClick={handleDots}>
      &#10006;
    </div>
    <div className="replies">
      {isShowReplies && (
        <form onSubmit={submitCommentsHandler}>
          <div id="reply-form-template" className="add-comment">
            <textarea
              name="commenttitle"
              placeholder="Write a reply..."
              value={textArea.commenttitle}
              onChange={handleComments}
            ></textarea>
            <button type="submit">Post Reply</button>
          </div>
        </form>
      )}
      {comments.map((comment) => (
        <div
          className={`comment-for-comment ${
            showComments ? "" : "hidden"
          }`}
          key={comment.id}
        >
          <p className="comment-text">{comment.commenttitle}</p>
          <div className="comment-actions">
            <button className="like-btn">
              <ion-icon
                class="thumbs"
                name="thumbs-up-outline"
              ></ion-icon>{" "}
              0
            </button>
            <button className="dislike-btn">
              <ion-icon
                class="thumbs"
                name="thumbs-down-outline"
              ></ion-icon>{" "}
              0
            </button>
            <button className="reply-btn" onClick={handleShowReplies}>
              reply
            </button>
            <button className="edit-btn">Edit</button>
            <button className="delete-btn">Delete</button>
            <small className="comment-note">{`${comment?.User?.name}, ответил ${post?.User?.name}`}</small>
          </div>
        </div>
      ))}
    </div>
  </div>
</div>
</div> */
}





To allow editing a post when the Edit button is clicked, you can add an edit mode that lets users update the content of a post. This will involve adding a function to handle the edit, a state to toggle between view and edit modes, and an input field for editing the post content.

Here's how to implement this:

Add a new isEditing state to track whether the post is in edit mode.
Add a new editText state to store the text while editing.
Update the handleEdit function to toggle edit mode and pre-fill the editText state with the current post content.
Add a submitEditHandler function to save the edited content.
Here’s the modified code:

import React, { useState, useEffect } from "react";

export default function Postcard({ post, id, userIDsession }) {
  const [isDotsActive, setIsDotsActive] = useState(false);
  const [isShowReplies, setShowReplies] = useState(false);
  const [textArea, setTextArea] = useState({
    commenttitle: "",
  });
  const [comments, setComments] = useState([]);
  const [showComments, setShowComments] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(post.posttitle);

  const handleDots = () => {
    setIsDotsActive(!isDotsActive);
  };
  const handleShowReplies = () => {
    setShowReplies(!isShowReplies);
  };
  const handleComments = (e) => {
    setTextArea((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };
  const handleShowComments = () => {
    setShowComments(!showComments);
  };

  const handleEdit = () => {
    setIsEditing(true);
    setEditText(post.posttitle);
  };

  const handleEditChange = (e) => {
    setEditText(e.target.value);
  };

  const submitEditHandler = async (e) => {
    e.preventDefault();
    const response = await fetch(`/api/posts/${id}`, {
      method: "PUT",
      headers: { "Content-type": "application/json" },
      body: JSON.stringify({ posttitle: editText }),
    });
    if (response.ok) {
      setIsEditing(false);
      post.posttitle = editText; // Update the post content
    }
  };

  const submitCommentsHandler = async (e) => {
    e.preventDefault();
    if (!textArea.commenttitle.trim()) {
      setTextArea({ commenttitle: "" });
      setShowReplies(false);
      return;
    }
    const response = await fetch(`/api/comments/${id}`, {
      method: "POST",
      headers: { "Content-type": "application/json" },
      body: JSON.stringify({ commenttitle: textArea.commenttitle }),
    });
    if (response.ok) {
      const data = await response.json();
      setComments((prevComments) => [...prevComments, data]);
      setTextArea({ commenttitle: "" });
      setShowReplies(false);
    }
  };

  useEffect(() => {
    fetch(`/api/comments/${id}`, { method: "GET" })
      .then((res) => res.json())
      .then((data) => setComments(data))
      .catch((err) => console.log(err));
  }, [id]);

  return (
    <>
      <div className={`comment-section ${isDotsActive ? "show-actions" : ""}`}>
        <button className="toggle-comments-btn" onClick={handleShowComments}>
          {`${showComments ? "Скрыть" : "Комментарии"} ${comments.length}`}
        </button>
        <div className="comment-list">
          <div className="comment">
            {isEditing ? (
              <form onSubmit={submitEditHandler}>
                <textarea
                  value={editText}
                  onChange={handleEditChange}
                  placeholder="Edit your post..."
                ></textarea>
                <button type="submit">Save</button>
                <button type="button" onClick={() => setIsEditing(false)}>
                  Cancel
                </button>
              </form>
            ) : (
              <p className="comment-text">{post.posttitle}</p>
            )}
            <div className="comment-actions">
              <button className="like-btn">
                <ion-icon className="thumbs" name="thumbs-up-outline"></ion-icon> 0
              </button>
              <button className="dislike-btn">
                <ion-icon className="thumbs" name="thumbs-down-outline"></ion-icon> 0
              </button>
              <button className="reply-btn" onClick={handleShowReplies}>
                reply
              </button>
              {userIDsession === post.user_id && (
                <button className="edit-btn" onClick={handleEdit}>
                  Edit
                </button>
              )}
              <small className="comment-note">
                {post?.User?.name}, ({post?.Subject?.subjectName})
              </small>
            </div>
            {/* Other JSX remains the same */}
          </div>
          {/* Comment replies section */}
        </div>
      </div>
    </>
  );
}

Explanation
Edit Mode: When the Edit button is clicked, isEditing is set to true, and the editText state is initialized with the current post title.
Edit Form: In edit mode, a form with a textarea and Save/Cancel buttons is shown.
Save Edit: When the form is submitted, the submitEditHandler function sends the updated post title to the server and updates the post content if the request succeeds.
Cancel: Clicking the Cancel button exits edit mode without saving changes.
This setup allows inline editing of the post title with minimal changes to the existing code.



как лучше написать в react.js логику изменение постов.
Создать новый компонент который будет открываться при нажатии на кнопку изменить или же менять в самом компоненте?

Оба подхода — создание нового компонента для редактирования или реализация редактирования внутри текущего компонента — имеют свои преимущества и зависят от структуры вашего приложения и требований. Давайте разберем плюсы и минусы каждого из них, чтобы выбрать лучший подход.

1. Создание отдельного компонента для редактирования поста
Преимущества

Лучшая модульность: Выделение логики редактирования в отдельный компонент улучшает читаемость и повторное использование кода.
Удобство тестирования: Отдельный компонент проще тестировать, так как он изолирован от остальной логики отображения.
Упрощение основного компонента: Основной компонент останется более чистым, без лишней логики редактирования.
Переиспользование: Если требуется редактировать посты в разных частях приложения, отдельный компонент можно легко использовать в других местах.
Минусы
Дополнительная передача пропсов: Вам нужно будет передавать текущий пост и функции обратного вызова для сохранения изменений и обновления данных обратно в основной компонент.
Сложность обработки состояния: Нужно учитывать, как обновления из компонента редактирования будут передаваться в родительский компонент и обновлять состояние.
Пример реализации с отдельным компонентом

import React, { useState } from 'react';

function Postcard({ post, userIDsession, onUpdatePost }) {
  const [isEditActive, setIsEditActive] = useState(false);

  const handleEditClick = () => {
    setIsEditActive(true);
  };

  const handleEditClose = () => {
    setIsEditActive(false);
  };

  return (
    <div>
      {isEditActive ? (
        <EditPostForm post={post} onSave={onUpdatePost} onClose={handleEditClose} />
      ) : (
        <div>
          <p>{post.posttitle}</p>
          {userIDsession === post.user_id && (
            <button onClick={handleEditClick}>Edit</button>
          )}
        </div>
      )}
    </div>
  );
}

function EditPostForm({ post, onSave, onClose }) {
  const [editText, setEditText] = useState(post.posttitle);

  const handleSave = () => {
    onSave({ ...post, posttitle: editText });
    onClose();
  };

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <textarea value={editText} onChange={(e) => setEditText(e.target.value)} />
      <button type="button" onClick={handleSave}>Save</button>
      <button type="button" onClick={onClose}>Cancel</button>
    </form>
  );
}

export default Postcard;



2. Изменение поста в самом компоненте
Преимущества

Простота: Нет необходимости создавать новый компонент и передавать данные через пропсы, что может упростить код.
Управление состоянием в одном месте: Все состояние, включая редактирование, находится в одном компоненте, что иногда упрощает логику.
Минусы

Увеличение объема кода в компоненте: Логика редактирования делает компонент более громоздким.
Потенциальные сложности с управлением состоянием: Если компонент уже сложный и содержит много логики, добавление редактирования может привести к запутанности.
Пример реализации редактирования в самом компоненте

import React, { useState } from 'react';

function Postcard({ post, userIDsession, onUpdatePost }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(post.posttitle);

  const handleEditClick = () => {
    setIsEditing(true);
  };

  const handleSave = () => {
    onUpdatePost({ ...post, posttitle: editText });
    setIsEditing(false);
  };

  return (
    <div>
      {isEditing ? (
        <div>
          <textarea value={editText} onChange={(e) => setEditText(e.target.value)} />
          <button onClick={handleSave}>Save</button>
          <button onClick={() => setIsEditing(false)}>Cancel</button>
        </div>
      ) : (
        <div>
          <p>{post.posttitle}</p>
          {userIDsession === post.user_id && (
            <button onClick={handleEditClick}>Edit</button>
          )}
        </div>
      )}
    </div>
  );
}

export default Postcard;

Вывод
Создание отдельного компонента стоит выбрать, если редактирование поста может понадобиться в других частях приложения или если основной компонент становится слишком сложным.
Редактирование в том же компоненте подходит для небольших приложений или случаев, когда нужно редактировать посты только в одном месте.
Оба подхода работают, выбор зависит от структуры вашего приложения и того, как вы планируете поддерживать и расширять код в будущем.






import React, { useState } from "react";
import { NavLink } from "react-router-dom";

export default function Contentlist({ directions, thumbnails, userIDsession }) {
  const [selectedItemIndex, setSelectedItemIndex] = useState(0);
  const [carouselItems, setCarouselItems] = useState(directions);
  const [thumbnailItems, setThumbnailItems] = useState(thumbnails);

  const handleClick = (index) => {
    setSelectedItemIndex(index + 1);

    // Перемещение выбранного элемента в конец списка
    const updatedCarouselItems = [
      ...carouselItems.slice(0, index),
      ...carouselItems.slice(index + 1),
      carouselItems[index],
    ];
    setCarouselItems(updatedCarouselItems);

    const updatedThumbnailItems = [
      ...thumbnailItems.slice(0, index),
      ...thumbnailItems.slice(index + 1),
      thumbnailItems[index],
    ];
    setThumbnailItems(updatedThumbnailItems);
  };
